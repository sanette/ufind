<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ufind</title><meta charset="utf-8"/><link rel="stylesheet" href="odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="index.html">Index</a> &#x00BB; <a href="../index.html">ufind</a> &#x00BB; Ufind</nav><header class="odoc-preamble"><h1>Module <code><span>Ufind</span></code></h1><p>Case insensitive, accent insensitive search engine</p><p>Ufind is a small <a href="https://ocaml.org/">ocaml</a> library that provides a case insentitive, accent insensitive search in strings encoded in utf8. It is meant to be easy to use, either for searching simple lists, or for digging in large databases.</p><p>Thanks to <a href="https://sanette.github.io/ubase/">Ubase</a>, accents and more general diacritics are recognized for all Latin characters. For other alphabets/scripts, searching will remain accent sensitive.</p><p><a href="https://github.com/sanette/ufind">Source on github</a></p><ul class="at-tags"><li class="version"><span class="at-tag">version</span> 0.01</li></ul></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#examples">Examples</a></li><li><a href="#search-filters">Search filters</a><ul><li><a href="#casefolding">Casefolding</a></li><li><a href="#matching-defect">Matching defect</a></li></ul></li><li><a href="#searching">Searching</a><ul><li><a href="#preparing-the-data">Preparing the data</a></li><li><a href="#search-results">Search results</a></li></ul></li><li><a href="#utilities">Utilities</a><ul><li><a href="#sequences">Sequences</a></li><li><a href="#string-conversions">String conversions</a></li><li><a href="#mysql-interface">Mysql interface</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>The simplest search function is <a href="#val-filter_list"><code>filter_list</code></a>; you can use it for searching an arbitrary list with only one line of code:</p><pre class="language-ocaml"><code> # let list = [1,&quot;Arthur&quot;; 2,&quot;Benoît&quot;; 3,&quot;Camille&quot;; 4,&quot;Damián&quot;] in
   Ufind.filter_list ~get_name:snd &quot;á&quot; list;;

 - : (int * string) list = [(4, &quot;Dami\195\161n&quot;); (1, &quot;Arthur&quot;); (3, &quot;Camille&quot;)] </code></pre><p>Note that the results are sorted by relevance; the best match is &quot;Damián&quot; because it has an &quot;á&quot; with the correct accent.</p><p>However, for better speed <em>and</em> memory usage, as soon as you intend to do several searches in the same database, we recommend using a two-step approach, as in the example below.</p><p>Let us search a substring in a list of strings. Here we use the <code>sample</code> list of names that can be found in the test directory.</p><p>First we prepare the data:</p><pre class="language-ocaml"><code># let items = Ufind.items_from_names sample;;
val items : string Ufind.search_item Seq.t = &lt;fun&gt;</code></pre><p>And then we may search:</p><pre class="language-ocaml"><code># let result = Ufind.select_data items &quot;ap&quot;;;
val result : string list =
  [&quot;Olivia Apodaca&quot;; &quot;Gi\195\161p \196\144\195\180ng Ngh\225\187\139&quot;]
# List.iter print_endline result;;
Olivia Apodaca
Giáp Đông Nghị
- : unit = ()</code></pre><p>The string &quot;Olivia Apodaca&quot; came first, because the substring &quot;ap&quot; is present without any accent substitution. If we searched &quot;áp&quot; instead, the order of the results would have been inverted.</p><h2 id="search-filters"><a href="#search-filters" class="anchor"></a>Search filters</h2><p>The search can be greatly modified by playing with two filters: <em>casefolding</em> and <em>matching_defect</em>.</p><h3 id="casefolding"><a href="#casefolding" class="anchor"></a>Casefolding</h3><p>The <code>casefolding</code> parameter is the function used to perform a <b>case-insensitive</b> search. Two strings that have the same image under this function will be considered equal (exact match).</p><p>This function is applied only in the preprocess stage, see below.</p><div class="odoc-spec"><div class="spec type anchored" id="type-casefolding"><a href="#type-casefolding" class="anchor"></a><code><span><span class="keyword">type</span> casefolding</span><span> = </span></code><ol><li id="type-casefolding.CF_D144" class="def variant constructor anchored"><a href="#type-casefolding.CF_D144" class="anchor"></a><code><span>| </span><span><span class="constructor">CF_D144</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><a href="https://unicode.org/versions/Unicode17.0.0/core-spec/chapter-3/#G53513">Unicode Core Spec</a>.</p><span class="comment-delim">*)</span></div></li><li id="type-casefolding.CF_D145" class="def variant constructor anchored"><a href="#type-casefolding.CF_D145" class="anchor"></a><code><span>| </span><span><span class="constructor">CF_D145</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><a href="https://unicode.org/versions/Unicode17.0.0/core-spec/chapter-3/#G53523">Unicode Core Spec</a>.</p><span class="comment-delim">*)</span></div></li><li id="type-casefolding.CF_D147" class="def variant constructor anchored"><a href="#type-casefolding.CF_D147" class="anchor"></a><code><span>| </span><span><span class="constructor">CF_D147</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><a href="https://unicode.org/versions/Unicode17.0.0/core-spec/chapter-3/#G53539">Unicode Core Spec</a>.</p><span class="comment-delim">*)</span></div></li><li id="type-casefolding.CF_NONE" class="def variant constructor anchored"><a href="#type-casefolding.CF_NONE" class="anchor"></a><code><span>| </span><span><span class="constructor">CF_NONE</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>no transformation</p><span class="comment-delim">*)</span></div></li><li id="type-casefolding.CF_LATIN145" class="def variant constructor anchored"><a href="#type-casefolding.CF_LATIN145" class="anchor"></a><code><span>| </span><span><span class="constructor">CF_LATIN145</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>D145 restricted to Latin letters</p><span class="comment-delim">*)</span></div></li><li id="type-casefolding.CF_LATIN147" class="def variant constructor anchored"><a href="#type-casefolding.CF_LATIN147" class="anchor"></a><code><span>| </span><span><span class="constructor">CF_LATIN147</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>D147 restricted to Latin letters</p><span class="comment-delim">*)</span></div></li><li id="type-casefolding.CF_ASCII" class="def variant constructor anchored"><a href="#type-casefolding.CF_ASCII" class="anchor"></a><code><span>| </span><span><span class="constructor">CF_ASCII</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>ASCII lowercase</p><span class="comment-delim">*)</span></div></li><li id="type-casefolding.CF_CUSTOM" class="def variant constructor anchored"><a href="#type-casefolding.CF_CUSTOM" class="anchor"></a><code><span>| </span><span><span class="constructor">CF_CUSTOM</span> <span class="keyword">of</span> <span>string <span class="arrow">→</span></span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>any compatible function -- see below</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>For enforcing a <b>case-sensitive</b> search, just use <code>CF_NONE</code>. The casefolding function can also be used to <em>normalize</em> the utf8 string; this is done by <code>CF_D145</code> and <code>CF_D147</code>. However, recall that normalizing is a slow operation, and it should rather be done directly when storing items in your database. The expected properties of the casefolding function are:</p><ul><li>Removing accents (with <a href="#val-utf8_to_ascii"><code>utf8_to_ascii</code></a>) followed by casefolding should give the same result as casefolding followed by removing accents. The resulting string is called the base string. It contains only ASCII characters.</li></ul><ul><li>Applying casefolding on a base string should return the unmodified string.</li></ul><ul><li>If two items have different base strings, they will never match in any search.</li></ul><ul><li>If two items have the same base string, they should match in any search, but maybe we a low ranking (low matching quality).</li></ul><p>Expected property for case-insensitive search:</p><ul><li>Equality of casefolded ASCII strings should be equivalent to equality of the strings obtained by applying <code>String.lowercase_ascii</code>.</li></ul><p>CUSTOM casefolding functions can be used for specific cases. For instance, one can use <a href="#val-capitalize_casefold"><code>capitalize_casefold</code></a>, which combines a usual lower-case function with capitalizing the first letter. In this way we force the match to happen at the start of the string: &quot;Ver&quot; (or &quot;ver&quot;) will match with &quot;Véronique&quot; and &quot;VÉRONIQUE&quot; but not with &quot;Prévert&quot; or &quot;PRÉVERT&quot;. Of course, the same result can be obtained by a simple <a href="#type-matching_defect"><code>matching_defect</code></a> function, see below.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-capitalize_casefold"><a href="#val-capitalize_casefold" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> capitalize_casefold</span> : <span>string <span class="arrow">→</span></span> string</span></code></div></div><h3 id="matching-defect"><a href="#matching-defect" class="anchor"></a>Matching defect</h3><p>Ufind uses a function that establishes the quality of &quot;A being a substring of B&quot;. It is entirely parameterizable. It should be fast and <em>not</em> deal with accents, only raw strings.</p><div class="odoc-spec"><div class="spec type anchored" id="type-matching_defect"><a href="#type-matching_defect" class="anchor"></a><code><span><span class="keyword">type</span> matching_defect</span><span> = </span></code><ol><li id="type-matching_defect.MD_EQUAL" class="def variant constructor anchored"><a href="#type-matching_defect.MD_EQUAL" class="anchor"></a><code><span>| </span><span><span class="constructor">MD_EQUAL</span></span></code></li><li id="type-matching_defect.MD_SUBSTRING" class="def variant constructor anchored"><a href="#type-matching_defect.MD_SUBSTRING" class="anchor"></a><code><span>| </span><span><span class="constructor">MD_SUBSTRING</span></span></code></li><li id="type-matching_defect.MD_CUSTOM" class="def variant constructor anchored"><a href="#type-matching_defect.MD_CUSTOM" class="anchor"></a><code><span>| </span><span><span class="constructor">MD_CUSTOM</span> <span class="keyword">of</span> <span><span>(string * string)</span> <span class="arrow">→</span></span> <span><span>(string * string)</span> <span class="arrow">→</span></span> <span>int option</span></span></code></li></ol></div></div><ul><li>The default matching defect is <code>MD_SUBSTRING</code>. For this function, the defect increases with the position of the substring A within the string B, and with the difference between their respective sizes.</li></ul><ul><li><code>MD_EQUAL</code> only accepts strict equality of strings. Equal strings have zero defect, and non-equal strings have undefined defect.</li></ul><ul><li><code>MD_CUSTOM f</code> will compute the defect with the function <code>f</code>, which takes two arguments, each one of the form <code>(name, base)</code>, where <code>name</code> is a utf8 string, and <code>base</code> its ASCII version. The function <code>f</code> should have the following properties:</li></ul><p><code>f s1 s2</code> returns <code>None</code> if <code>s1</code> is not considered as a substring of <code>s2</code> (whatever you want it to mean); otherwise</p><p><code>f s1 s2</code> returns <code>Some d</code> where the non-negative integer <code>d</code> measures the defect of <code>s1</code> being &quot;close&quot; to <code>s2</code>. (The &quot;best match&quot; should return <code>d=0</code>.)</p><p><code>f s1 s2</code> returns <code>Some 0</code> if <code>s1 = s2</code>.</p><p>A good matching_defect function should primarily compare the &quot;name&quot; components of <code>s1</code> and <code>s2</code>; it does not need to take into account their &quot;base&quot; components. However, it must be consistent in the following way:</p><p>If <code>f (name1, base1) (name2, base2) &lt;&gt; None</code> then we must have <code>f (base1, &quot;&quot;) (base2, &quot;&quot;) &lt;&gt; None</code> as well.</p><p><em>In future versions, we plan to implement functions that accept small typing errors, like permutations of two consecutive letters. But right now, you need to write your own function for this feature.</em></p><h2 id="searching"><a href="#searching" class="anchor"></a>Searching</h2><p>The Ufind library is meant for searching through a database by filtering a string field, typically a name. We use the vocabulary &quot;name&quot; for denoting the field in question; but of course, it can be any string field, as long as it is UTF8 encoded.</p><h3 id="preparing-the-data"><a href="#preparing-the-data" class="anchor"></a>Preparing the data</h3><p>Before searching, the data has to be preprocessed, in order to transform it into a sequence of <a href="#type-search_item"><code>search_item</code></a>s. The preprocess can be lazy (will be executed only when real search queries will be made), but if memory allows it, it will be much faster to preprocess the whole data in memory, especially if you intend to perform several searches in the same database.</p><p>A search item does not have to contain all the data of the original records, it only contains the &quot;name&quot; field and a &quot;data&quot; pointer to recover the original data.</p><div class="odoc-spec"><div class="spec type anchored" id="type-search_item"><a href="#type-search_item" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a search_item</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-base_of_item"><a href="#val-base_of_item" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> base_of_item</span> : <span><span><span class="type-var">'a</span> <a href="#type-search_item">search_item</a></span> <span class="arrow">→</span></span> string</span></code></div><div class="spec-doc"><p>Return the ASCII version of the item.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-data_of_item"><a href="#val-data_of_item" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> data_of_item</span> : <span><span><span class="type-var">'a</span> <a href="#type-search_item">search_item</a></span> <span class="arrow">→</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return the data associated with the item.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-preprocess"><a href="#val-preprocess" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> preprocess</span> : 
  <span><span class="optlabel">?folding</span>:<a href="#type-casefolding">casefolding</a> <span class="arrow">→</span></span>
  <span><span class="optlabel">?limit</span>:<span>(int * int)</span> <span class="arrow">→</span></span>
  <span><span class="label">get_name</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">→</span></span> string)</span> <span class="arrow">→</span></span>
  <span><span class="label">get_data</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">→</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">→</span></span>
  <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">→</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-search_item">search_item</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>preprocess ~get_name ~get_data seq</code> returns a sequence of <code>search_item</code>s from the source sequence <code>seq</code>.</p><p>This function is a general way of obtaining a sequence of search items from any kind of data source, as long as this source can be accessed by a sequence (ocaml type <code>Seq.t</code>). The function <code>get_name</code> takes an element of the sequence and should return the name field that we are searching. The function <code>get_data</code> on an element of the sequence can return any type of data that we want to associate with the result of the search. It can be the same as <code>get_name</code>. But, the data can also be the id of the correspondng record, so that from the result of the search on the name field we can recover the other fields of the matching records.</p><p>The <a href="#val-preprocess"><code>preprocess</code></a> function is <em>not</em> lazy; as a consequence, the resulting sequence is very fast to search. If <code>limit=(offset,count)</code>, <code>preprocess</code> will force evaluation of the first <code>offset+count</code> elements of the sequence <code>seq</code>, and return a sequence of at most <code>count</code> effectively computed <code>search_items</code> starting at item #<code>offset</code> (inclusive). Warning, if no <code>limit</code> is given, the whole <code>seq</code> is processed; hence if <code>seq</code> is infinite, it will never terminate until memory overflows.</p><p>In all <code>preprocess*</code> functions, the returned sequence is not mutable, has no side-effect, and will always point to the start of the source sequence. So there is no need to reset it for each new search.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-preprocess_list"><a href="#val-preprocess_list" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> preprocess_list</span> : 
  <span><span class="optlabel">?folding</span>:<a href="#type-casefolding">casefolding</a> <span class="arrow">→</span></span>
  <span><span class="label">get_name</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">→</span></span> string)</span> <span class="arrow">→</span></span>
  <span><span class="label">get_data</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">→</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">→</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">→</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-search_item">search_item</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-preprocess"><code>preprocess</code></a> but the database is a list instead of a sequence.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-preprocess_file"><a href="#val-preprocess_file" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> preprocess_file</span> : 
  <span><span class="optlabel">?limit</span>:<span>(int * int)</span> <span class="arrow">→</span></span>
  <span><span class="label">get_name</span>:<span>(<span>string <span class="arrow">→</span></span> string)</span> <span class="arrow">→</span></span>
  <span><span class="label">get_data</span>:<span>(<span>string <span class="arrow">→</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">→</span></span>
  <span>string <span class="arrow">→</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-search_item">search_item</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Use this to search in a file, where each item must be encoded in a single line.</p><p>The name field should be obtained by <code>get_name line</code>, and the data field by <code>get_data line</code>. Returns the sequence of pre-processed search items.</p></div></div><p>The <code>items_from*</code> functions below, contrary to the <code>preprocess*</code> functions, immediately return a lazy sequence of <code>search_item</code>s that will be evaluated on-the-fly when needed. They may be mutable on not, depending on the nature of the source sequence they depend upon.</p><p>If needed, any sequence of <code>search_item</code>s can be transformed into a preprocessed one by applying <a href="#val-seq_eval"><code>seq_eval</code></a>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-items_from_seq"><a href="#val-items_from_seq" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> items_from_seq</span> : 
  <span><span class="optlabel">?folding</span>:<a href="#type-casefolding">casefolding</a> <span class="arrow">→</span></span>
  <span><span class="label">get_name</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">→</span></span> string)</span> <span class="arrow">→</span></span>
  <span><span class="label">get_data</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">→</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">→</span></span>
  <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">→</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-search_item">search_item</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-preprocess"><code>preprocess</code></a> except that there is no preprocessing: this immediately returns a lazy sequence of items, suitable for searching.</p><p>If the source sequence is mutable (most sequences are), then for each new search, it has to be reset to its origin position, and a new call to <code>items_from_seq</code> is required.</p><p>If memory allows and if you intend to perform several searches, use <a href="#val-preprocess"><code>preprocess</code></a> for faster searching.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-items_from_names"><a href="#val-items_from_names" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> items_from_names</span> : 
  <span><span class="optlabel">?folding</span>:<a href="#type-casefolding">casefolding</a> <span class="arrow">→</span></span>
  <span><span>string list</span> <span class="arrow">→</span></span>
  <span><span>string <a href="#type-search_item">search_item</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>items_from_names list</code> immediately returns a lazy sequence of search items from a list of strings.</p><p>The returned sequence is not mutable, and will always point to the start of the list. So there is no need to reset it for each new search.</p><p>For faster searching, rather use <code>preprocess_list ~get_name:id ~get_data:id list</code>, where <code>id x = x</code>. The only interest of <code>items_from_names</code> is when the list is really long and we don't want to duplicate it in memory.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-items_from_text"><a href="#val-items_from_text" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> items_from_text</span> : 
  <span><span class="optlabel">?folding</span>:<a href="#type-casefolding">casefolding</a> <span class="arrow">→</span></span>
  <span>string <span class="arrow">→</span></span>
  <span><span><span>(int * string)</span> <a href="#type-search_item">search_item</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>items_from_text text</code> immediately constructs a lazy list of search_item corresponding to each word of the string <code>text</code>, where word delimiters are <code>[ \t\n()]</code>. Usual punctuation signs are removed from the end of words.</p><p>The returned sequence is not mutable, and will always point to the start of the text. So there is no need to reset it for each new search.</p><p>After searching with <a href="#val-select_data"><code>select_data</code></a>, the resulting data is a list of pairs <code>(pos, word)</code> where <code>pos</code> is the position of the word in the original string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-items_from_channel"><a href="#val-items_from_channel" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> items_from_channel</span> : 
  <span><span class="optlabel">?folding</span>:<a href="#type-casefolding">casefolding</a> <span class="arrow">→</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.in_channel <span class="arrow">→</span></span>
  <span><span><span>(int * string)</span> <a href="#type-search_item">search_item</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>items_from_channel channel</code> immediately constructs a lazy list of search_item corresponding to each word read from the <code>channel</code>, where word delimiters are <code>[ \t\n()]</code>. Usual punctuation signs are removed from the end of words.</p><p>The resulting sequence is mutable, and will point to the current search position in the channel, which is not closed by this function.</p><p>After searching with <a href="#val-select_data"><code>select_data</code></a>, the resulting data is a list of pairs <code>(pos, word)</code> where <code>pos</code> is the byte position of the word in channel, starting from the initial state of the channel.</p></div></div><h3 id="search-results"><a href="#search-results" class="anchor"></a>Search results</h3><div class="odoc-spec"><div class="spec value anchored" id="val-select_data"><a href="#val-select_data" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> select_data</span> : 
  <span><span class="optlabel">?folding</span>:<a href="#type-casefolding">casefolding</a> <span class="arrow">→</span></span>
  <span><span class="optlabel">?stop</span>:<span>(<span><span><span class="type-var">'a</span> <a href="#type-search_item">search_item</a></span> <span class="arrow">→</span></span> bool)</span> <span class="arrow">→</span></span>
  <span><span class="optlabel">?matching_stop</span>:<span>(<span><span>(int * <span><span class="type-var">'a</span> <a href="#type-search_item">search_item</a></span>)</span> <span class="arrow">→</span></span> bool)</span> <span class="arrow">→</span></span>
  <span><span class="optlabel">?matching_defect</span>:<a href="#type-matching_defect">matching_defect</a> <span class="arrow">→</span></span>
  <span><span><span><span class="type-var">'a</span> <a href="#type-search_item">search_item</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">→</span></span>
  <span>string <span class="arrow">→</span></span>
  <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>select_data items name</code> searches for the string <code>name</code> within the sequence of search items <code>items</code> and returns the sorted list of data corresponding to matching items.</p><p>If <code>stop</code> is not provided, the search will explore the whole sequence. Otherwise, the search will stop after processing the first <code>item</code> in <code>items</code> for which <code>stop item = true</code>. The argument <code>matching_stop</code> operates in a similar way, but is executed only on matching items, and its argument is the couple <code>(distance, item)</code>.</p><p>The <code>folding</code> parameter must be the same as the one used to create the <code>items</code> sequence.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_stop"><a href="#val-make_stop" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> make_stop</span> : 
  <span><span class="optlabel">?count</span>:int <span class="arrow">→</span></span>
  <span><span class="optlabel">?timeout</span>:float <span class="arrow">→</span></span>
  <span>unit <span class="arrow">→</span></span>
  <span>(<span><span class="type-var">'a</span> <span class="arrow">→</span></span> bool)</span> * <span>(<span>unit <span class="arrow">→</span></span> bool)</span></span></code></div><div class="spec-doc"><p><code>make_stop ~count ~timeout ()</code> returns the pair <code>(stop, flag)</code>, where <code>stop</code> is a 'stop' function suitable for use in <a href="#val-select_data"><code>select_data</code></a>; and <code>flag</code> is a function that returns <code>true</code> when the stop test is effectively triggered.</p><p>When used with <a href="#val-select_data"><code>select_data</code></a>, the search will stop after processing <code>count</code> elements, or when the <code>timeout</code> (in seconds) is elapsed. Note that the timer starts as soon at the unit argument <code>()</code> is provided.</p><p>The stop function has to be created again after each use.</p><p>In conjunction with <a href="#val-seq_split"><code>seq_split</code></a>, the <code>flag</code> can be used to resume a previously stopped search, as follows.</p><pre class="language-ocaml"><code>let seq1, seq2 = seq_split items in
  let stop, flag = make_stop ~count:10 () in
  let result = select_data ~stop seq1 name in
if flag () then begin
  print_endline &quot;The search was interrupted. We resume it.&quot;;
  let result2 = select_data seq2 name in
  (* ...now the complete result is the union {result,result2},
        but the global ranking is lost... *)
end else print_endline &quot;The search was complete.&quot;</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_list"><a href="#val-filter_list" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> filter_list</span> : 
  <span><span class="optlabel">?folding</span>:<a href="#type-casefolding">casefolding</a> <span class="arrow">→</span></span>
  <span><span class="optlabel">?matching_defect</span>:<a href="#type-matching_defect">matching_defect</a> <span class="arrow">→</span></span>
  <span><span class="label">get_name</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">→</span></span> string)</span> <span class="arrow">→</span></span>
  <span>string <span class="arrow">→</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">→</span></span>
  <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>This is the simplest search function; it doesn't require any preprocessing. <code>filter_list ~get_name name list</code> will filter (and sort by relevance) the given <code>list</code> by returning only those elements whose name field (extracted by <code>get_name</code>) matches <code>name</code>.</p><p>Example: </p><pre class="language-ocaml"><code>         # let list = [1,&quot;Arthur&quot;; 2,&quot;Benoît&quot;; 3,&quot;Camille&quot;; 4,&quot;Damián&quot;] in
  filter_list ~get_name:snd &quot;á&quot; list;;

- : (int * string) list = [(4, &quot;Dami\195\161n&quot;); (1, &quot;Arthur&quot;); (3, &quot;Camille&quot;)]</code></pre><p>Because the returned list is just a subset of the initial list, one can easily refine a search by chaining several calls to <code>filter_list</code>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Matching"><a href="#module-Matching" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Matching/index.html">Matching</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Obtaining detailed matching results</p></div></div><h2 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h2><h3 id="sequences"><a href="#sequences" class="anchor"></a>Sequences</h3><p>Sequences, or &quot;delayed lists&quot; is a standard data type in ocaml, see <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Seq.html">here</a>. They represent lists where each element is obtained by evaluating some function, and the evaluation is &quot;lazy&quot;, <em>i.e.</em> is done only when absolutely needed.</p><p><em>(In order to keep the Ufind library compatible with ocaml 4.05, the newer <code>Seq</code> functions that appeared in 4.07 are not used.)</em></p><div class="odoc-spec"><div class="spec value anchored" id="val-seq_to_list_rev"><a href="#val-seq_to_list_rev" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> seq_to_list_rev</span> : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">→</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Evaluate the whole sequence and convert it to a list, in reverse order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list_to_seq"><a href="#val-list_to_seq" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> list_to_seq</span> : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">→</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Immediately return a lazy sequence from the given list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_eval"><a href="#val-seq_eval" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> seq_eval</span> : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">→</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Evaluate the whole sequence and return a new sequence with the evaluated values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_truncate"><a href="#val-seq_truncate" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> seq_truncate</span> : <span>int <span class="arrow">→</span></span> <span>int <span class="arrow">→</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">→</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>(Half)-immediate truncation of a sequence. <code>seq_truncate offset count seq</code> returns a sequence of length <code>count</code> (or less in case the initial sequence is too short) containing the elements of the initial <code>seq</code> starting at the <code>offset</code>-eth element.</p><p>This operation is not entirely lazy: elements before #<code>offset</code> will be evaluated. But no other element.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_stop"><a href="#val-seq_stop" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> seq_stop</span> : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">→</span></span> bool)</span> <span class="arrow">→</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">→</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>seq_stop stop seq</code> returns a lazy truncation of the sequence <code>seq</code>. When evaluated, the sequence will stop just after the function <code>stop</code> evaluated on an element returns true. For instance <code>stop</code> can be a timer, see <a href="#val-make_stop"><code>make_stop</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_split"><a href="#val-seq_split" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> seq_split</span> : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">→</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> * <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Dynamic splittig of a sequence. If <code>s1,s2 = seq_split seq</code> then <code>s2</code> will always start after the last evaluated element of <code>s1</code>.</p><p>For instance if we let <code>st = seq_truncate 0 10 s1</code> and iterate on <code>st</code>, then the iteration of <code>s2</code> will start at the 11th element of <code>seq</code>.</p></div></div><h3 id="string-conversions"><a href="#string-conversions" class="anchor"></a>String conversions</h3><p>Shortcuts to some <a href="https://sanette.github.io/ubase/">Ubase</a> functions.</p><div class="odoc-spec"><div class="spec value anchored" id="val-isolatin_to_utf8"><a href="#val-isolatin_to_utf8" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> isolatin_to_utf8</span> : <span>string <span class="arrow">→</span></span> string</span></code></div><div class="spec-doc"><p>Convert ISO_8859_1 to UTF8</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-utf8_to_ascii"><a href="#val-utf8_to_ascii" class="anchor"></a><code><span><span class="keyword">val</span><span class="val"> utf8_to_ascii</span> : <span>string <span class="arrow">→</span></span> string</span></code></div><div class="spec-doc"><p>Convert to ASCII by removing all accents on Latin letters, and removing all other non-ascii chars or non-Latin letters.</p><p>Example:</p><pre class="language-ocaml"><code># utf8_to_ascii &quot;¡Déjà vu!&quot;;;
- : string = &quot;Deja vu!&quot;</code></pre></div></div><h3 id="mysql-interface"><a href="#mysql-interface" class="anchor"></a>Mysql interface</h3><p>See <a href="https://github.com/sanette/ufind/blob/master/ufind_mysql.md">an example here</a>.</p></div></body></html>
