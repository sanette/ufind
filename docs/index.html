<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ufind</title><link rel="stylesheet" href="odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">ufind</a> &#x00BB; Ufind</nav><h1>Module <code>Ufind</code></h1><p>Case insensitive, accent insensitive search engine</p><p>Ufind is a small <a href="https://ocaml.org/">ocaml</a> library that provides a case insentitive, accent insensitive search in strings encoded in utf8. It is meant to be easy to use, either for searching simple lists, or for digging in large databases.</p><p>Thanks to <a href="https://sanette.github.io/ubase/">Ubase</a>, accents and more general diacritics are recognized for all Latin characters. For other alphabets/scripts, searching will remain accent sensitive.</p><p><a href="https://github.com/sanette/ufind">Source on github</a></p><dl><dt>version</dt><dd>0.01</dd></dl><nav class="toc"><ul><li><a href="#example">Example</a></li><li><a href="#search-filters">Search filters</a><ul><li><a href="#casefolding">Casefolding</a></li><li><a href="#matching-defect">Matching defect</a></li></ul></li><li><a href="#searching">Searching</a><ul><li><a href="#preparing-the-data">Preparing the data</a></li><li><a href="#search-results">Search results</a></li></ul></li><li><a href="#utilities">Utilities</a><ul><li><a href="#sequences">Sequences</a></li><li><a href="#string-conversions">String conversions</a></li></ul></li></ul></nav></header><section><header><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><p>For searching a substring in a list of strings, you only need two lines of code. Here we use the <code>sample</code> list of names that can be found in the test directory.</p><p>First we prepare the data:</p><pre><code class="ml"># let items = Ufind.items_from_names sample;;
val items : string Ufind.search_item Seq.t = &lt;fun&gt;</code></pre><p>And then we may search:</p><pre><code class="ml"># let result = Ufind.select_data items &quot;ap&quot;;;
val result : string list =
  [&quot;Olivia Apodaca&quot;; &quot;Gi\195\161p \196\144\195\180ng Ngh\225\187\139&quot;]
# List.iter print_endline result;;
Olivia Apodaca
Giáp Đông Nghị
- : unit = ()                 </code></pre><p>The string &quot;Olivia Apodaca&quot; came first, because the substring &quot;ap&quot; is present without any accent substitution. If we searched &quot;áp&quot; instead, the order of the results would have been inverted.</p></header></section><section><header><h2 id="search-filters"><a href="#search-filters" class="anchor"></a>Search filters</h2><p>The search can be greatly modified by playing with two filters: <em>casefolding</em> and <em>matching_defect</em>.</p></header><section><header><h3 id="casefolding"><a href="#casefolding" class="anchor"></a>Casefolding</h3><p>The <code>casefolding</code> parameter is the function used to perform a <b>case-insensitive</b> search. Two strings that have the same image under this function will be considered equal (exact match).</p><p>This function is applied only in the preprocess stage, see below.</p></header><dl><dt class="spec type" id="type-casefolding"><a href="#type-casefolding" class="anchor"></a><code><span class="keyword">type</span> casefolding</code><code> = </code><table class="variant"><tr id="type-casefolding.CF_D144" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_D144" class="anchor"></a><code>| </code><code><span class="constructor">CF_D144</span></code></td><td class="doc"><p><a href="http://unicode.org/versions/latest/ch03.pdf">Unicode Core Spec</a>, page 157.</p></td></tr><tr id="type-casefolding.CF_D145" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_D145" class="anchor"></a><code>| </code><code><span class="constructor">CF_D145</span></code></td><td class="doc"><p><a href="http://unicode.org/versions/latest/ch03.pdf">Unicode Core Spec</a>, page 158.</p></td></tr><tr id="type-casefolding.CF_D147" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_D147" class="anchor"></a><code>| </code><code><span class="constructor">CF_D147</span></code></td><td class="doc"><p><a href="http://unicode.org/versions/latest/ch03.pdf">Unicode Core Spec</a>, page 158.</p></td></tr><tr id="type-casefolding.CF_NONE" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_NONE" class="anchor"></a><code>| </code><code><span class="constructor">CF_NONE</span></code></td><td class="doc"><p>no transformation</p></td></tr><tr id="type-casefolding.CF_LATIN145" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_LATIN145" class="anchor"></a><code>| </code><code><span class="constructor">CF_LATIN145</span></code></td><td class="doc"><p>D145 restricted to Latin letters</p></td></tr><tr id="type-casefolding.CF_LATIN147" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_LATIN147" class="anchor"></a><code>| </code><code><span class="constructor">CF_LATIN147</span></code></td><td class="doc"><p>D147 restricted to Latin letters</p></td></tr><tr id="type-casefolding.CF_ASCII" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_ASCII" class="anchor"></a><code>| </code><code><span class="constructor">CF_ASCII</span></code></td><td class="doc"><p>ASCII lowercase</p></td></tr><tr id="type-casefolding.CF_CUSTOM" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_CUSTOM" class="anchor"></a><code>| </code><code><span class="constructor">CF_CUSTOM</span> <span class="keyword">of</span> string <span>&#45;&gt;</span> string</code></td><td class="doc"><p>any compatible function -- see below</p></td></tr></table></dt><dd><p>For enforcing a <b>case-sensitive</b> search, just use <code>CF_NONE</code>. The casefolding function can also be used to <em>normalize</em> the utf8 string; this is done by <code>CF_D145</code> and <code>CF_D147</code>. However, recall that normalizing is a slow operation, and it should rather be done directly when storing items in your database. The expected properties of the casefolding function are:</p><ul><li>Removing accents (with <a href="index.html#val-utf8_to_ascii"><code>utf8_to_ascii</code></a>) followed by casefolding should give the same result as casefolding followed be removing accents. The resulting string is called the base string. It contains only ASCII characters.</li></ul><ul><li>Applying casefolding on a base string should return the unmodified string.</li></ul><ul><li>If two items have different base strings, they will never match in any search.</li></ul><ul><li>If two items have the same base string, they should match in any search, but maybe we a low ranking (low matching quality).</li></ul><p>Expected property for case-insensitive search:</p><ul><li>Equality of casefolded ASCII strings should be equivalent to equality of the strings obtained by applying <code>String.lowercase_ascii</code>.</li></ul><p>CUSTOM casefolding functions can be used for specific cases. For instance, one can use <a href="index.html#val-capitalize_casefold"><code>capitalize_casefold</code></a>, which combines a usual lower-case function with capitalizing the first letter. In this way we force the match to happen at the start of the string: &quot;Ver&quot; (or &quot;ver&quot;) will match with &quot;Véronique&quot; and &quot;VÉRONIQUE&quot; but not with &quot;Prévert&quot; or &quot;PRÉVERT&quot;. Of course, the same result can be obtained by a simple <a href="index.html#type-matching_defect"><code>matching_defect</code></a> function, see below.</p></dd></dl><dl><dt class="spec value" id="val-capitalize_casefold"><a href="#val-capitalize_casefold" class="anchor"></a><code><span class="keyword">val</span> capitalize_casefold : string <span>&#45;&gt;</span> string</code></dt></dl></section><section><header><h3 id="matching-defect"><a href="#matching-defect" class="anchor"></a>Matching defect</h3><p>Ufind uses a function that establishes the quality of &quot;A being a substring of B&quot;. It is entirely parameterizable. It should be fast and <em>not</em> deal with accents, only raw strings.</p></header><dl><dt class="spec type" id="type-matching_defect"><a href="#type-matching_defect" class="anchor"></a><code><span class="keyword">type</span> matching_defect</code><code> = </code><table class="variant"><tr id="type-matching_defect.MD_EQUAL" class="anchored"><td class="def constructor"><a href="#type-matching_defect.MD_EQUAL" class="anchor"></a><code>| </code><code><span class="constructor">MD_EQUAL</span></code></td></tr><tr id="type-matching_defect.MD_SUBSTRING" class="anchored"><td class="def constructor"><a href="#type-matching_defect.MD_SUBSTRING" class="anchor"></a><code>| </code><code><span class="constructor">MD_SUBSTRING</span></code></td></tr><tr id="type-matching_defect.MD_CUSTOM" class="anchored"><td class="def constructor"><a href="#type-matching_defect.MD_CUSTOM" class="anchor"></a><code>| </code><code><span class="constructor">MD_CUSTOM</span> <span class="keyword">of</span> <span>(string * string)</span> <span>&#45;&gt;</span> <span>(string * string)</span> <span>&#45;&gt;</span> <span>int option</span></code></td></tr></table></dt></dl><aside><ul><li>The default matching defect is <code>MD_SUBSTRING</code>. For this function, the defect increases with the position of the substring A within the string B, and with the difference between their respective sizes.</li></ul><ul><li><code>MD_EQUAL</code> only accepts strict equality of strings. Equal strings have zero defect, and non-equal strings have undefined defect.</li></ul><ul><li><code>MD_CUSTOM f</code> will compute the defect with the function <code>f</code>, which takes two arguments, each one of the form <code>(name, base)</code>, where <code>name</code> is a utf8 string, and <code>base</code> its ASCII version. The function <code>f</code> should have the following properties:</li></ul><p><code>f s1 s2</code> returns <code>None</code> if <code>s1</code> is not considered as a substring of <code>s2</code> (whatever you want it to mean); otherwise</p><p><code>f s1 s2</code> returns <code>Some d</code> where the non-negative integer <code>d</code> measures the defect of <code>s1</code> being &quot;close&quot; to <code>s2</code>. (The &quot;best match&quot; should return <code>d=0</code>.)</p><p><code>f s1 s2</code> returns <code>Some 0</code> if <code>s1 = s2</code>.</p><p>A good matching_defect function should primarily compare the &quot;name&quot; components of <code>s1</code> and <code>s2</code>; it does not need to take into account their &quot;base&quot; components. However, it must be consistent in the following way:</p><p>If <code>f (name1, base1) (name2, base2) &lt;&gt; None</code> then we must have <code>f (base1, &quot;&quot;) (base2, &quot;&quot;) &lt;&gt; None</code> as well.</p><p><em>In future versions, we plan to implement functions that accept small typing errors, like permutations of two consecutive letters. But right now, you need to write your own function for this feature.</em></p></aside></section></section><section><header><h2 id="searching"><a href="#searching" class="anchor"></a>Searching</h2><p>The Ufind library is meant for searching through a database by filtering a string field, typically a name. We use the vocabulary &quot;name&quot; for denoting the field in question; but of course, it can be any string field, as long as it is UTF8 encoded.</p></header><section><header><h3 id="preparing-the-data"><a href="#preparing-the-data" class="anchor"></a>Preparing the data</h3><p>Before searching, the data has to be preprocessed, in order to transform it into a sequence of <a href="index.html#type-search_item"><code>search_item</code></a>s. The preprocess can be lazy (will be executed only when real search queries will be made), but if memory allows it, it will be much faster to preprocess the whole data in memory, especially if you intend to perform several searches in the same database.</p><p>A search item does not have to contain all the data of the original records, it only contains the &quot;name&quot; field and a &quot;data&quot; pointer to recover the original data.</p></header><dl><dt class="spec type" id="type-search_item"><a href="#type-search_item" class="anchor"></a><code><span class="keyword">type</span> <span>'a search_item</span></code></dt></dl><dl><dt class="spec value" id="val-base_of_item"><a href="#val-base_of_item" class="anchor"></a><code><span class="keyword">val</span> base_of_item : <span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p>Return the ASCII version of the item.</p></dd></dl><dl><dt class="spec value" id="val-data_of_item"><a href="#val-data_of_item" class="anchor"></a><code><span class="keyword">val</span> data_of_item : <span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the data associated with the item.</p></dd></dl><dl><dt class="spec value" id="val-preprocess"><a href="#val-preprocess" class="anchor"></a><code><span class="keyword">val</span> preprocess : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> <span>?&#8288;limit:<span>(int * int)</span></span> <span>&#45;&gt;</span> <span>get_name:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>get_data:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Seq.t</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt><dd><p><code>preprocess ~get_name ~get_data seq</code> returns a sequence of <code>search_item</code>s from the source sequence <code>seq</code>.</p><p>This function is a general way of obtaining a sequence of search items from any kind of data source, as long as this source can be accessed by a sequence (ocaml type <code>Seq.t</code>). The function <code>get_name</code> takes an element of the sequence and should return the name field that we are searching. The function <code>get_data</code> on an element of the sequence can return any type of data that we want to associate with the result of the search. It can be the same as <code>get_name</code>. But, the data can also be the id of the correspondng record, so that from the result of the search on the name field we can recover the other fields of the matching records.</p><p>The <a href="index.html#val-preprocess"><code>preprocess</code></a> function is <em>not</em> lazy; as a consequence, the resulting sequence is very fast to search. If <code>limit=(offset,count)</code>, <code>preprocess</code> will force evaluation of the first <code>offset+count</code> elements of the sequence <code>seq</code>, and return a sequence of at most <code>count</code> effectively computed <code>search_items</code> starting at item #<code>offset</code> (inclusive). Warning, if no <code>limit</code> is given, the whole <code>seq</code> is processed; hence if <code>seq</code> is infinite, it will never terminate until memory overflows.</p><p>In all <code>preprocess*</code> functions, the returned sequence is not mutable, has no side-effect, and will always point to the start of the source sequence. So there is no need to reset it for each new search.</p></dd></dl><dl><dt class="spec value" id="val-preprocess_list"><a href="#val-preprocess_list" class="anchor"></a><code><span class="keyword">val</span> preprocess_list : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> <span>get_name:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>get_data:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt><dd><p>Same as <a href="index.html#val-preprocess"><code>preprocess</code></a> but the database is a list instead of a sequence.</p></dd></dl><dl><dt class="spec value" id="val-preprocess_file"><a href="#val-preprocess_file" class="anchor"></a><code><span class="keyword">val</span> preprocess_file : <span>?&#8288;limit:<span>(int * int)</span></span> <span>&#45;&gt;</span> <span>get_name:<span>(string <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>get_data:<span>(string <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt><dd><p>Use this to search in a file, where each item must be encoded in a single line. The name field should be obtained by <code>get_name line</code>, and the data field by <code>get_data line</code>. Returns the sequence of pre-processed search items.</p></dd></dl><aside><p>The <code>items_from*</code> functions below, contrary to the <code>preprocess*</code> functions, immediately return a lazy sequence of <code>search_item</code>s that will be evaluated on-the-fly when needed. They may be mutable on not, depending on the nature of the source sequence they depend upon.</p><p>If needed, any sequence of <code>search_item</code>s can be transformed into a preprocessed one by applying <a href="index.html#val-seq_eval"><code>seq_eval</code></a>.</p></aside><dl><dt class="spec value" id="val-items_from_seq"><a href="#val-items_from_seq" class="anchor"></a><code><span class="keyword">val</span> items_from_seq : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> <span>get_name:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>get_data:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Seq.t</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt><dd><p>Similar to <a href="index.html#val-preprocess"><code>preprocess</code></a> except that there is no preprocessing: this immediately returns a lazy sequence of items, suitable for searching.</p><p>If the source sequence is mutable (most sequences are), then for each new search, it has to be reset to its origin position, and a new call to <code>items_from_seq</code> is required.</p><p>If memory allows and if you intend to perform several searches, use <a href="index.html#val-preprocess"><code>preprocess</code></a> for faster searching.</p></dd></dl><dl><dt class="spec value" id="val-items_from_names"><a href="#val-items_from_names" class="anchor"></a><code><span class="keyword">val</span> items_from_names : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <span><span>string <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt><dd><p><code>items_from_names list</code> immediately returns a lazy sequence of search items from a list of strings.</p><p>The returned sequence is not mutable, and will always point to the start of the list. So there is no need to reset it for each new search.</p><p>For faster searching, rather use <code>preprocess_list ~get_name:id ~get_data:id
   list</code>, where <code>id x = x</code>. The only interest of <code>items_from_names</code> is when the list is really long and we don't want to duplicate it in memory.</p></dd></dl><dl><dt class="spec value" id="val-items_from_text"><a href="#val-items_from_text" class="anchor"></a><code><span class="keyword">val</span> items_from_text : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span><span>(int * string)</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt><dd><p><code>items_from_text text</code> immediately constructs a lazy list of search_item corresponding to each word of the string <code>text</code>, where word delimiters are <code>[ \t\n()]</code>. Usual punctuation signs are removed from the end of words.</p><p>The returned sequence is not mutable, and will always point to the start of the text. So there is no need to reset it for each new search.</p><p>After searching with <a href="index.html#val-select_data"><code>select_data</code></a>, the resulting data is a list of pairs <code>(pos, word)</code> where <code>pos</code> is the position of the word in the original string.</p></dd></dl><dl><dt class="spec value" id="val-items_from_channel"><a href="#val-items_from_channel" class="anchor"></a><code><span class="keyword">val</span> items_from_channel : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> Pervasives.in_channel <span>&#45;&gt;</span> <span><span><span>(int * string)</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt></dl><aside><p><code>items_from_channel channel</code> immediately constructs a lazy list of search_item corresponding to each word read from the <code>channel</code>, where word delimiters are <code>[ \t\n()]</code>. Usual punctuation signs are removed from the end of words.</p><p>The resulting sequence is mutable, and will point to the current search position in the channel, which is not closed by this function.</p><p>After searching with <a href="index.html#val-select_data"><code>select_data</code></a>, the resulting data is a list of pairs <code>(pos, word)</code> where <code>pos</code> is the byte position of the word in channel, starting from the initial state of the channel.</p></aside></section><section><header><h3 id="search-results"><a href="#search-results" class="anchor"></a>Search results</h3></header><dl><dt class="spec value" id="val-select_data"><a href="#val-select_data" class="anchor"></a><code><span class="keyword">val</span> select_data : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> <span>?&#8288;stop:<span>(<span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;matching_stop:<span>(<span>(int * <span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span>)</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;matching_defect:<a href="index.html#type-matching_defect">matching_defect</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>select_data seq name</code> searches for the string <code>name</code> within the sequence of search items <code>seq</code> and returns the sorted list of data corresponding to matching items.</p><p>If <code>stop</code> is not provided, the search will explore the whole sequence. Otherwise, the search will stop after processing the first <code>item</code> in <code>seq</code> for which <code>stop item = true</code>. The argument <code>matching_stop</code> operates in a similar way, but is executed only on matching items, and its argument is the couple <code>(distance, item)</code>.</p></dd></dl><dl><dt class="spec value" id="val-make_stop"><a href="#val-make_stop" class="anchor"></a><code><span class="keyword">val</span> make_stop : <span>?&#8288;count:int</span> <span>&#45;&gt;</span> <span>?&#8288;timeout:float</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>make_stop ~count ~timeout ()</code> creates a 'stop' function suitable for use in <a href="index.html#val-select_data"><code>select_data</code></a>.</p><p>It will stop after processing <code>count</code> elements, or when the <code>timeout</code> (in seconds) is elapsed. Note that the timer starts as soon at the unit argument <code>()</code> is provided.</p><p>The stop function has to be created again after each use.</p></dd></dl></section></section><section><header><h2 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h2></header><section><header><h3 id="sequences"><a href="#sequences" class="anchor"></a>Sequences</h3><p><em>(In order to keep the Ufind library compatible with ocaml 4.05, the newer <code>Seq</code> functions that appeared in 4.07 are not used.)</em></p></header><dl><dt class="spec value" id="val-seq_to_list_rev"><a href="#val-seq_to_list_rev" class="anchor"></a><code><span class="keyword">val</span> seq_to_list_rev : <span><span class="type-var">'a</span> Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Evaluate the whole sequence and convert it to a list, in reverse order.</p></dd></dl><dl><dt class="spec value" id="val-list_to_seq"><a href="#val-list_to_seq" class="anchor"></a><code><span class="keyword">val</span> list_to_seq : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Seq.t</span></code></dt><dd><p>Immediately return a lazy sequence from the given list.</p></dd></dl><dl><dt class="spec value" id="val-seq_eval"><a href="#val-seq_eval" class="anchor"></a><code><span class="keyword">val</span> seq_eval : <span><span class="type-var">'a</span> Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Seq.t</span></code></dt><dd><p>Evaluate the whole sequence and return a new sequence with the evaluated values.</p></dd></dl><dl><dt class="spec value" id="val-seq_truncate"><a href="#val-seq_truncate" class="anchor"></a><code><span class="keyword">val</span> seq_truncate : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Seq.t</span></code></dt><dd><p>(Half)-immediate truncation of a sequence. <code>seq_truncate offset count seq</code> returns a sequence of length <code>count</code> (or less in case the initial sequence is too short) containing the elements of the initial <code>seq</code> starting at the <code>offset</code>-eth element.</p><p>This operation is not entirely lazy: elements before #<code>offset</code> will be evaluated. But no other element.</p></dd></dl><dl><dt class="spec value" id="val-seq_split"><a href="#val-seq_split" class="anchor"></a><code><span class="keyword">val</span> seq_split : <span><span class="type-var">'a</span> Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Seq.t</span> * <span><span class="type-var">'a</span> Seq.t</span></code></dt><dd><p>Dynamic splittig of a sequence. If <code>s1,s2 = seq_split seq</code> then <code>s2</code> will always start after the last evaluated element of <code>s1</code>.</p><p>For instance if we let <code>st = seq_truncate 0 10 s1</code> and iterate on <code>st</code>, then the iteration of <code>s2</code> will start at the 11th element of <code>seq</code>.</p></dd></dl></section><section><header><h3 id="string-conversions"><a href="#string-conversions" class="anchor"></a>String conversions</h3><p>Shortcuts to some <a href="https://sanette.github.io/ubase/">Ubase</a> functions.</p></header><dl><dt class="spec value" id="val-isolatin_to_utf8"><a href="#val-isolatin_to_utf8" class="anchor"></a><code><span class="keyword">val</span> isolatin_to_utf8 : string <span>&#45;&gt;</span> string</code></dt><dd><p>Convert ISO_8859_1 to UTF8</p></dd></dl><dl><dt class="spec value" id="val-utf8_to_ascii"><a href="#val-utf8_to_ascii" class="anchor"></a><code><span class="keyword">val</span> utf8_to_ascii : string <span>&#45;&gt;</span> string</code></dt><dd><p>Convert to ASCII by removing all accents on Latin letters, and ignoring all non-ascii chars or non-Latin letters.</p></dd></dl></section></section></div></body></html>