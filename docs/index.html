<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ufind</title><link rel="stylesheet" href="odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">ufind</a> &#x00BB; Ufind</nav><h1>Module <code>Ufind</code></h1><p>Case insensitive, accent insensitive search engine</p><p>Ufind is a small library that provides a case insentitive, accent insensitive search in strings encoded in utf8. It is meant to be easy to use, either for searching simple lists, or for digging in large databases.</p><p>Accents are more general diacritics are recognized for all Latin characters. For other alphabets, searching will remain accent sensitive.</p><p><a href="https://github.com/sanette/ufind">github</a></p><dl><dt>version</dt><dd>0.01</dd></dl><nav class="toc"><ul><li><a href="#example">Example</a></li><li><a href="#casefolding">Casefolding</a></li><li><a href="#searching">Searching</a><ul><li><a href="#preparing-the-data">Preparing the data</a></li><li><a href="#search-results">Search results</a></li></ul></li><li><a href="#utilities-for-sequences">Utilities for sequences</a></li></ul></nav></header><section><header><h3 id="example"><a href="#example" class="anchor"></a>Example</h3><p>Here <code>sample</code> is a list of names that can be found in the test directory.</p><p>First we prepare the data:</p><pre><code class="ml"># let items = Ufind.items_from_names sample;;
val items : string Ufind.search_item Seq.t = &lt;fun&gt;</code></pre><p>And then we may search:</p><pre><code class="ml"># let result = Ufind.select_data items &quot;ap&quot;;;
val result : string list =
  [&quot;Olivia Apodaca&quot;; &quot;Gi\195\161p \196\144\195\180ng Ngh\225\187\139&quot;]
# List.iter print_endline result;;
Olivia Apodaca
Giáp Đông Nghị
- : unit = ()                 </code></pre></header></section><section><header><h3 id="casefolding"><a href="#casefolding" class="anchor"></a>Casefolding</h3><p>The <code>casefolding</code> parameter is the function used to perform a <b>case-insensitive</b> search. Two strings that have the same image under this function will be considered equal (exact match).</p></header><dl><dt class="spec type" id="type-casefolding"><a href="#type-casefolding" class="anchor"></a><code><span class="keyword">type</span> casefolding</code> = <code>[ </code><table class="variant"><tr id="type-casefolding.CF_D144" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_D144" class="anchor"></a><code>| </code><code>`CF_D144</code></td><td class="doc"><p>http://unicode.org/versions/latest/ch03.pdf page 157.</p></td></tr><tr id="type-casefolding.CF_D145" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_D145" class="anchor"></a><code>| </code><code>`CF_D145</code></td><td class="doc"><p>http://unicode.org/versions/latest/ch03.pdf page 158.</p></td></tr><tr id="type-casefolding.CF_D147" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_D147" class="anchor"></a><code>| </code><code>`CF_D147</code></td><td class="doc"><p>http://unicode.org/versions/latest/ch03.pdf page 158.</p></td></tr><tr id="type-casefolding.CF_NONE" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_NONE" class="anchor"></a><code>| </code><code>`CF_NONE</code></td><td class="doc"><p>no transformation</p></td></tr><tr id="type-casefolding.CF_LATIN144" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_LATIN144" class="anchor"></a><code>| </code><code>`CF_LATIN144</code></td><td class="doc"><p>D144 restricted to Latin letters</p></td></tr><tr id="type-casefolding.CF_LATIN147" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_LATIN147" class="anchor"></a><code>| </code><code>`CF_LATIN147</code></td><td class="doc"><p>D147 restricted to Latin letters</p></td></tr><tr id="type-casefolding.CF_ASCII" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_ASCII" class="anchor"></a><code>| </code><code>`CF_ASCII</code></td><td class="doc"><p>ASCII lowercase</p></td></tr><tr id="type-casefolding.CF_CUSTOM" class="anchored"><td class="def constructor"><a href="#type-casefolding.CF_CUSTOM" class="anchor"></a><code>| </code><code>`CF_CUSTOM <span class="keyword">of</span> string <span>&#45;&gt;</span> string</code></td></tr></table><code> ]</code></dt><dd><p>For enforcing a <b>case-sensitive</b> search, just use <code>`CF_NONE</code>. The casefolding function can also be used to <em>normalize</em> the utf8 string; this is done by <code>`CF_D145</code> and <code>`CF_D147</code>. However, recall that normalizing is a slow operation, and it should rather be done directly when storing items in your database. The expected properties of the casefolding function are:</p><ul><li>Removing accents (with Ubase) followed by casefolding should give the same result as casefolding followed be removing accents. The resulting string is called the base string. It contains only ASCII characters.</li></ul><ul><li>Applying casefolding on a base string should return the unmodified string.</li></ul><ul><li>If two items have different base strings, they will never match in any search.</li></ul><ul><li>If two items have the same base string, they should match in any search, but maybe we a low ranking (low matching quality).</li></ul><p>Expected property for case-insensitive search:</p><ul><li>Equality of casefolded ASCII strings should be equivalent to equality of the strings obtained by applying <code>String.lowercase_ascii</code>.</li></ul><p>CUSTOM casefolding functions can be used for specific cases. For instance, a useful one, <a href="index.html#val-capitalize_casefold"><code>capitalize_casefold</code></a>, is to combine a usual lower-case function with capitalizing the first letter. In this way, &quot;Ver&quot; (or &quot;ver&quot;) will match with &quot;Véronique&quot; and &quot;VÉRONIQUE&quot; but not with &quot;Prévert&quot; or &quot;PRÉVERT&quot;.</p></dd></dl><dl><dt class="spec value" id="val-capitalize_casefold"><a href="#val-capitalize_casefold" class="anchor"></a><code><span class="keyword">val</span> capitalize_casefold : string <span>&#45;&gt;</span> string</code></dt></dl></section><section><header><h3 id="searching"><a href="#searching" class="anchor"></a>Searching</h3><p>The library is meant for searching through a database by filtering a string field, typically a name. We use the vocabulary &quot;name&quot; for denoting the field in question.</p></header><section><header><h4 id="preparing-the-data"><a href="#preparing-the-data" class="anchor"></a>Preparing the data</h4><p>Before searching, the data has to be preprocessed, in order to transform it into a sequence of <a href="index.html#type-search_item"><code>search_item</code></a>s. The preprocess can be lazy (will be executed only when real search queries will be made), but if memory allows it, it will be much faster to preprocess the whole data in memory, especially if you intend to perform several searches in the same database.</p><p>A search item does not have to contain all the data of the original records, it only contains the &quot;name&quot; field and a &quot;data&quot; pointer to recover the original data.</p></header><dl><dt class="spec type" id="type-search_item"><a href="#type-search_item" class="anchor"></a><code><span class="keyword">type</span> <span>'a search_item</span></code></dt></dl><dl><dt class="spec value" id="val-base_of_item"><a href="#val-base_of_item" class="anchor"></a><code><span class="keyword">val</span> base_of_item : <span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p>Return the ASCII version of the item.</p></dd></dl><dl><dt class="spec value" id="val-data_of_item"><a href="#val-data_of_item" class="anchor"></a><code><span class="keyword">val</span> data_of_item : <span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the data associated with the item.</p></dd></dl><dl><dt class="spec value" id="val-preprocess"><a href="#val-preprocess" class="anchor"></a><code><span class="keyword">val</span> preprocess : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> <span>?&#8288;limit:<span>(int * int)</span></span> <span>&#45;&gt;</span> <span>get_name:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>get_data:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Seq.t</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt><dd><p><code>preprocess ~get_name ~get_data seq</code> is a general way of obtaining a sequence of search items from any kind of data source, as long as it can be converted into a sequence. The function <code>get_name</code> takes an element of the sequence and should return the name field that we are searching. The function <code>get_data</code> on an element of the sequence can return any type of data that we want to associate with the result of the search. It can be the same as <code>get_name</code>. But, the data can also be the id of the correspondng record, so that from the result of the search on the name field we can recover the other fields of the matching records.</p><p>If <code>limit=(first,length)</code>, <code>preprocess</code> will force evaluation of the first <code>first+length</code> elements of the sequence <code>seq</code>, and return a sequence of at most <code>length</code> effectively computed <code>search_items</code> starting at item #<code>start</code> (inclusive). Warning, if no <code>limit</code> is given, the whole <code>seq</code> is processed; hence if <code>seq</code> is infinite, it will never terminate until memory overflow.</p></dd></dl><dl><dt class="spec value" id="val-preprocess_list"><a href="#val-preprocess_list" class="anchor"></a><code><span class="keyword">val</span> preprocess_list : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> <span>get_name:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>get_data:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt><dd><p>Same as <a href="index.html#val-preprocess"><code>preprocess</code></a> but the database is a list instead of a sequence.</p></dd></dl><dl><dt class="spec value" id="val-preprocess_file"><a href="#val-preprocess_file" class="anchor"></a><code><span class="keyword">val</span> preprocess_file : <span>?&#8288;limit:<span>(int * int)</span></span> <span>&#45;&gt;</span> <span>get_name:<span>(string <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>get_data:<span>(string <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt><dd><p>Open a file for searching, where each item must be encoded in a line. The name field should be obtained by <code>get_name line</code>, and the data field by <code>get_data line</code>. Returns the sequence of pre-processed search items.</p></dd></dl><dl><dt class="spec value" id="val-items_from_seq"><a href="#val-items_from_seq" class="anchor"></a><code><span class="keyword">val</span> items_from_seq : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Seq.t</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt><dd><p>Similar to <a href="index.html#val-preprocess"><code>preprocess</code></a> except that there is no preprocessing: this immediately returns a lazy sequence of items, suitable for searching. If memory allows and if you intend to perform several searches, use <a href="index.html#val-preprocess"><code>preprocess</code></a> for faster searching.</p></dd></dl><dl><dt class="spec value" id="val-items_from_names"><a href="#val-items_from_names" class="anchor"></a><code><span class="keyword">val</span> items_from_names : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <span><span>string <a href="index.html#type-search_item">search_item</a></span> Seq.t</span></code></dt><dd><p><code>items_from_names list</code> returns a lazy sequence of search items from a list of strings. For faster searching, rather use <code>preprocess_list ~get_name:id
   ~get_data:id list</code>, where <code>id x = x</code>. The only interest of <code>items_from_names</code> is when the list is really long and we don't want to duplicate it in memory.</p></dd></dl></section><section><header><h4 id="search-results"><a href="#search-results" class="anchor"></a>Search results</h4><p>All search functions operate on a sequence of search_items.</p></header><dl><dt class="spec value" id="val-select_data"><a href="#val-select_data" class="anchor"></a><code><span class="keyword">val</span> select_data : <span>?&#8288;folding:<a href="index.html#type-casefolding">casefolding</a></span> <span>&#45;&gt;</span> <span>?&#8288;stop:<span>(<span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;matching_stop:<span>(<span>(int * <span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span>)</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-search_item">search_item</a></span> Seq.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>select_data seq name</code> searches for the string <code>name</code> within the sequence of search items <code>seq</code> and returns the sorted list of data corresponding to matching items. If <code>stop</code> is not provided, the search will explore the whole sequence. Otherwise, the search will stop when <code>stop item = true</code>, where <code>item</code> is the current item in <code>seq</code>. The argument <code>matching_stop</code> operates in a similar way, but is executed only on matching items, and its argument is the couple <code>(distance, item)</code>.</p></dd></dl><dl><dt class="spec value" id="val-make_stop"><a href="#val-make_stop" class="anchor"></a><code><span class="keyword">val</span> make_stop : <span>?&#8288;length:int</span> <span>&#45;&gt;</span> <span>?&#8288;timeout:float</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>make_stop ~length ~timeout ()</code> creates a 'stop' function suitable for use in <a href="index.html#val-select_data"><code>select_data</code></a>. It will stop after processing <code>length</code> elements, or when the <code>timeout</code> (in seconds) is elapsed. Note that the timer starts as soon at the unit argument <code>()</code> is provided.</p></dd></dl></section></section><section><header><h3 id="utilities-for-sequences"><a href="#utilities-for-sequences" class="anchor"></a>Utilities for sequences</h3></header><dl><dt class="spec value" id="val-seq_to_list_rev"><a href="#val-seq_to_list_rev" class="anchor"></a><code><span class="keyword">val</span> seq_to_list_rev : <span><span class="type-var">'a</span> Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>Evaluate the whole sequence and convert it to a list, in reverse order.</p></dd></dl><dl><dt class="spec value" id="val-seq_truncate"><a href="#val-seq_truncate" class="anchor"></a><code><span class="keyword">val</span> seq_truncate : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Seq.t</span></code></dt><dd><p>(Half)-immediate truncation of a sequence. <code>seq_truncate start length seq</code> returns a sequence of length <code>length</code> (or less in case the initial sequence is too short) containing the elements of the initial <code>seq</code> starting at the <code>start</code>-eth element. This operation is not entirely lazy: elements before #<code>start</code> will be evaluated. But no other element.</p></dd></dl></section></div></body></html>